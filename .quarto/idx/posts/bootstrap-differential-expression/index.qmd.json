{"title":"Bootstrapping Differential Expression","markdown":{"yaml":{"title":"Bootstrapping Differential Expression","description":"How many can I do?","author":"Gennaro Calendo","date":"9/22/2023","categories":["R","bioinformatics"]},"headingText":"Das Boot","containsRefs":false,"markdown":"\n\n\nI have been playing around with the idea of bootstrapping differential \nexpression analyses, inspired by [this](https://hbiostat.org/blog/post/badb/) \nexcellent blog post from Professor Frank Harrell on how to do bad biomarker \nresearch. In the section titled, \"Difficulties of picking 'winners'\" he writes:\n\n>Efron’s bootstrap can be used to fully account for the difficulty of the biomarker selection task. Selection of winners involves computing some statistic for each candidate marker, and sorting features by these strength-of-association measures. The statistic can be a crude unadjusted measure (correlation coefficient or unadjusted odds ratio, for example), or an adjusted measure. For each of a few hundred samples with replacement from the original raw dataset, one repeats the entire analysis afresh for each re-sample. All the biomarker candidates are ranked by the chosen statistic, and bootstrap percentile confidence intervals for these ranks are computed over all re-samples. 0.95 confidence limits for the rank of each candidate marker capture the stability of the ranks.\n\nSince I do a lot of analyses that involve differential expression testing where\nsamples are done in triplcate, I was curious if I could apply this resampling\nstrategy to my work to get a better idea of how often my winners are really \nwinners given we often have such small groups of samples. \n\nThis blog post is not about performing this bootstrapping workflow (I'll save\nthat for later). Rather, I want to explore how many unique bootstrap resamples\nwe expect to generate given triplicate samples and how often we should expect \nany given pattern to by sampled.\n\n## How many possible unique combinations of the data are there?\n\nSince a typical experiment consists of samples done in triplicate the question \nthen becomes, how many unique ways of bootstrapping samples are there? The \nreason I care about *unique* resamples is because when estimating differential\nexpression we are comparing the mean expression between two groups and therefore\na resample consisting of [control1, control1, control2] will give the same \nmean as resampling [control2, control1, control1].\n\nSince I'm no good at math, to examine this question I'll generate a grid of \nall possibilities and count up the unique combinations.\n\n```{r}\nlibrary(data.table)\n\n# Create all combinations of the three samples\nsamples <- c(\"A\", \"B\", \"C\")\ndt <- setDT(expand.grid(samples, samples, samples))\n\n# Combine into a single string representing the selected samples\ndt[, sample := paste0(Var1, Var2, Var3)]\n\n# Count up the number of letters represented in each string\ndt[, `:=`(N_A = stringr::str_count(sample, \"A\"),\n          N_B = stringr::str_count(sample, \"B\"),\n          N_C = stringr::str_count(sample, \"C\"))]\n\n# Count up the unique counts -- total number of rows gives the unique ways of\n#  generating bootstraps for triplicates\n(nrow(unique(dt[, .(N_A, N_B, N_C)])))\n```\n\nAs it turns out, this [question](https://stats.stackexchange.com/a/557626) \nhas been asked and answered already and the theoretical answer is given by $2n-1\\choose{n}$. So ${2(3)-1\\choose{3}}={5\\choose3}=10$\n\nJust to be sure, let's try again with 4 letters and check against the theoretical\nanswer\n\n```{r}\nsamples2 <- c(\"A\", \"B\", \"C\", \"D\")\ndt2 <- setDT(expand.grid(samples2, samples2, samples2, samples2))\ndt2[, sample := paste0(Var1, Var2, Var3, Var4)]\ndt2[, `:=`(N_A = stringr::str_count(sample, \"A\"),\n           N_B = stringr::str_count(sample, \"B\"),\n           N_C = stringr::str_count(sample, \"C\"),\n           N_D = stringr::str_count(sample, \"D\"))]\n(nrow(unique(dt2[, .(N_A, N_B, N_C, N_D)])))\n```\n\n```{r}\nchoose(2*4-1, 4)\n```\n\nSo if I want to generate bootstrap resamples for a 3x3 experiment there should be\n10 x 10 = 100 unique comparisons that I can make. But how often should we expect \nto see any given pattern in a set of triplicates if we perform a bunch of\nbootstraps?\n\n## Pattern counts\n\nWhat is the expected proportion of each pattern in the triplicate experiment if\nwe are to resample with replacement? We can find this by taking the proportions\nof each unique pattern from above.\n\n```{r}\n# Create a string from all of the unique ways to count samples\ndt[, patterns := paste0(N_A, N_B, N_C)]\n\n# Find the proportion of each of the possible ways to combine samples\nsort(table(dt$patterns) / sum(table(dt$patterns)))\n```\n\nWe can see that some patterns are more likely than others. For example, we are \njust as likely to select 0 As, 0 Bs, and 3 Cs as we are 3 As, 0 Bs, and 0 Cs. \nThis is interesting because it suggests that ~22% of our resamples should \ncontain the original samples, ~66% should contain one duplicated sample and \n~11% should contain triplicates of single sample.\n\nWe should see this if we generate samples and count the occurrences.\n\n```{r}\nset.seed(1011001)\n\nbootSamples <- function() {\n  # Generate the random string of selected samples\n  s <- paste(sample(c(\"A\", \"B\", \"C\"), replace = TRUE), collapse=\"\")\n  \n  # Count the number of times any individual occurs in the string\n  data.table(\n    N_A = stringr::str_count(s, \"A\"),\n    N_B = stringr::str_count(s, \"B\"),\n    N_C = stringr::str_count(s, \"C\")\n    )\n}\n\n# Generate 100 bootstrap resamples\nbootstraps <- replicate(1e2, bootSamples(), simplify = FALSE)\nbootstraps <- rbindlist(bootstraps)\nbootstraps[, patterns := paste0(N_A, N_B, N_C)]\n\n# Count the frequency of the observed patterns\nsort(table(bootstraps$patterns) / sum(table(bootstraps$patterns)))\n```\n\nGenerating 100 samples gets us close to the theoretical values and on average will converge on the theoretical values.\n\n## Thoughts\n\nThis is pretty interesting since it suggests that about 5% of the time (0.22 *\n0.22 = 0.048) when resampling two groups of triplicate samples I should expect to get back the same results as in the original analysis.\n","srcMarkdownNoYaml":"\n\n## Das Boot\n\nI have been playing around with the idea of bootstrapping differential \nexpression analyses, inspired by [this](https://hbiostat.org/blog/post/badb/) \nexcellent blog post from Professor Frank Harrell on how to do bad biomarker \nresearch. In the section titled, \"Difficulties of picking 'winners'\" he writes:\n\n>Efron’s bootstrap can be used to fully account for the difficulty of the biomarker selection task. Selection of winners involves computing some statistic for each candidate marker, and sorting features by these strength-of-association measures. The statistic can be a crude unadjusted measure (correlation coefficient or unadjusted odds ratio, for example), or an adjusted measure. For each of a few hundred samples with replacement from the original raw dataset, one repeats the entire analysis afresh for each re-sample. All the biomarker candidates are ranked by the chosen statistic, and bootstrap percentile confidence intervals for these ranks are computed over all re-samples. 0.95 confidence limits for the rank of each candidate marker capture the stability of the ranks.\n\nSince I do a lot of analyses that involve differential expression testing where\nsamples are done in triplcate, I was curious if I could apply this resampling\nstrategy to my work to get a better idea of how often my winners are really \nwinners given we often have such small groups of samples. \n\nThis blog post is not about performing this bootstrapping workflow (I'll save\nthat for later). Rather, I want to explore how many unique bootstrap resamples\nwe expect to generate given triplicate samples and how often we should expect \nany given pattern to by sampled.\n\n## How many possible unique combinations of the data are there?\n\nSince a typical experiment consists of samples done in triplicate the question \nthen becomes, how many unique ways of bootstrapping samples are there? The \nreason I care about *unique* resamples is because when estimating differential\nexpression we are comparing the mean expression between two groups and therefore\na resample consisting of [control1, control1, control2] will give the same \nmean as resampling [control2, control1, control1].\n\nSince I'm no good at math, to examine this question I'll generate a grid of \nall possibilities and count up the unique combinations.\n\n```{r}\nlibrary(data.table)\n\n# Create all combinations of the three samples\nsamples <- c(\"A\", \"B\", \"C\")\ndt <- setDT(expand.grid(samples, samples, samples))\n\n# Combine into a single string representing the selected samples\ndt[, sample := paste0(Var1, Var2, Var3)]\n\n# Count up the number of letters represented in each string\ndt[, `:=`(N_A = stringr::str_count(sample, \"A\"),\n          N_B = stringr::str_count(sample, \"B\"),\n          N_C = stringr::str_count(sample, \"C\"))]\n\n# Count up the unique counts -- total number of rows gives the unique ways of\n#  generating bootstraps for triplicates\n(nrow(unique(dt[, .(N_A, N_B, N_C)])))\n```\n\nAs it turns out, this [question](https://stats.stackexchange.com/a/557626) \nhas been asked and answered already and the theoretical answer is given by $2n-1\\choose{n}$. So ${2(3)-1\\choose{3}}={5\\choose3}=10$\n\nJust to be sure, let's try again with 4 letters and check against the theoretical\nanswer\n\n```{r}\nsamples2 <- c(\"A\", \"B\", \"C\", \"D\")\ndt2 <- setDT(expand.grid(samples2, samples2, samples2, samples2))\ndt2[, sample := paste0(Var1, Var2, Var3, Var4)]\ndt2[, `:=`(N_A = stringr::str_count(sample, \"A\"),\n           N_B = stringr::str_count(sample, \"B\"),\n           N_C = stringr::str_count(sample, \"C\"),\n           N_D = stringr::str_count(sample, \"D\"))]\n(nrow(unique(dt2[, .(N_A, N_B, N_C, N_D)])))\n```\n\n```{r}\nchoose(2*4-1, 4)\n```\n\nSo if I want to generate bootstrap resamples for a 3x3 experiment there should be\n10 x 10 = 100 unique comparisons that I can make. But how often should we expect \nto see any given pattern in a set of triplicates if we perform a bunch of\nbootstraps?\n\n## Pattern counts\n\nWhat is the expected proportion of each pattern in the triplicate experiment if\nwe are to resample with replacement? We can find this by taking the proportions\nof each unique pattern from above.\n\n```{r}\n# Create a string from all of the unique ways to count samples\ndt[, patterns := paste0(N_A, N_B, N_C)]\n\n# Find the proportion of each of the possible ways to combine samples\nsort(table(dt$patterns) / sum(table(dt$patterns)))\n```\n\nWe can see that some patterns are more likely than others. For example, we are \njust as likely to select 0 As, 0 Bs, and 3 Cs as we are 3 As, 0 Bs, and 0 Cs. \nThis is interesting because it suggests that ~22% of our resamples should \ncontain the original samples, ~66% should contain one duplicated sample and \n~11% should contain triplicates of single sample.\n\nWe should see this if we generate samples and count the occurrences.\n\n```{r}\nset.seed(1011001)\n\nbootSamples <- function() {\n  # Generate the random string of selected samples\n  s <- paste(sample(c(\"A\", \"B\", \"C\"), replace = TRUE), collapse=\"\")\n  \n  # Count the number of times any individual occurs in the string\n  data.table(\n    N_A = stringr::str_count(s, \"A\"),\n    N_B = stringr::str_count(s, \"B\"),\n    N_C = stringr::str_count(s, \"C\")\n    )\n}\n\n# Generate 100 bootstrap resamples\nbootstraps <- replicate(1e2, bootSamples(), simplify = FALSE)\nbootstraps <- rbindlist(bootstraps)\nbootstraps[, patterns := paste0(N_A, N_B, N_C)]\n\n# Count the frequency of the observed patterns\nsort(table(bootstraps$patterns) / sum(table(bootstraps$patterns)))\n```\n\nGenerating 100 samples gets us close to the theoretical values and on average will converge on the theoretical values.\n\n## Thoughts\n\nThis is pretty interesting since it suggests that about 5% of the time (0.22 *\n0.22 = 0.048) when resampling two groups of triplicate samples I should expect to get back the same results as in the original analysis.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.450","theme":"litera","title-block-banner":true,"title":"Bootstrapping Differential Expression","description":"How many can I do?","author":"Gennaro Calendo","date":"9/22/2023","categories":["R","bioinformatics"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}